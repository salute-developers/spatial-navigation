<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../demo/sample/spatnav-style.css">
    <link rel="stylesheet" href="test.css">
    <script src="../../polyfill/spatial-navigation-polyfill.js"></script>
  </head>

  <body>
    <div class="container" style="width:600px; height:200px;">
        <button class="box" id="A" style="position: absolute; left: 200px; height: 130px; width: 250px;"></button>
        <button class="box" id="B" style="position: absolute; top: 40px; left: 220px; height: 40px; width: 80px;"></button>
        <button class="box" id="C" style="position: absolute; top: 100px; left: 300px; height: 40px; width: 80px;"></button>
    </div>
    <div class="container" style="width:600px; height:200px;">
        <button class="box" id="A" style="position: absolute; left: 200px; height: 130px; width: 250px;"></button>
        <button class="box" id="B" style="position: absolute; top: 40px; left: 220px; height: 40px; width: 80px;"></button>
        <button class="box" id="C" style="position: absolute; top: 100px; left: 300px; height: 40px; width: 80px;"></button>
    </div>
  </body>
  <script type="text/javascript">
  const elmA = document.getElementById('A');
  const elmB = document.getElementById('B');
  const elmC = document.getElementById('C');

  console.log(`A and B [DOWN]: '${getDistance(elmA.getBoundingClientRect(), elmB.getBoundingClientRect(), 'down')}'`);
  console.log(`A and C [DOWN]: '${getDistance(elmA.getBoundingClientRect(), elmC.getBoundingClientRect(), 'down')}'`);

  function getDistance(searchOrigin, candidateRect, dir) {
      const kOrthogonalWeightForLeftRight = 30;
      const kOrthogonalWeightForUpDown = 2;

      let orthogonalBias = 0;
      let alignBias = 0;
      const alignWeight = 5.0;

      // Get exit point, entry point -> {x: '', y: ''};
      const points = getEntryAndExitPoints(dir, searchOrigin, candidateRect);

      // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate
      // that minimize the distance between these two points
      const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);
      const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);

      console.log(`=> P1 : '${P1}'`);
      console.log(`=> P2 : '${P2}'`);

      // A: The euclidean distance between P1 and P2.
      const A = Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));
      let B, C;

      // B: The absolute distance in the direction which is orthogonal to dir between P1 and P2, or 0 if dir is null.
      // C: The intersection edges between a candidate and the starting point.

      // D: The square root of the area of intersection between the border boxes of candidate and starting point
      const intersectionRect = getIntersectionRect(searchOrigin, candidateRect);
      const D = intersectionRect.area;

      switch (dir) {
      case 'left':
        /* falls through */
      case 'right' :
        // If two elements are aligned, add align bias
        // else, add orthogonal bias
        if (isAligned(searchOrigin, candidateRect, dir))
          alignBias = Math.min(intersectionRect.height / searchOrigin.height , 1);
        else
          orthogonalBias = (searchOrigin.height / 2);

        B = (P2 + orthogonalBias) * kOrthogonalWeightForLeftRight;
        C = alignWeight * alignBias;
        break;

      case 'up' :
        /* falls through */
      case 'down' :
        // If two elements are aligned, add align bias
        // else, add orthogonal bias
        if (isAligned(searchOrigin, candidateRect, dir))
          alignBias = Math.min(intersectionRect.width / searchOrigin.width , 1);
        else
          orthogonalBias = (searchOrigin.width / 2);

        B = (P1 + orthogonalBias) * kOrthogonalWeightForUpDown;
        C = alignWeight * alignBias;
        break;

      default:
        B = 0;
        C = 0;
        break;
      }

      console.log(`distance function : A + B + C - D ='${(A + B - C - D)}'`);
    console.log(`=> A : '${A}'`);
    console.log(`=> B : '${B}'`);
    console.log(`=> C : '${C}'`);
    console.log(`=> D : '${D}'`);

      return (A + B - C - D);
    }

    function getAbsoluteDistance(rect1, rect2, dir) {
      // Get exit point, entry point
      const points = getEntryAndExitPoints(dir, rect1, rect2);

      // Return the absolute distance in the dir direction between P1 and P.
      return ((dir === 'left') || (dir === 'right')) ?
        Math.abs(points.entryPoint.x - points.exitPoint.x) : Math.abs(points.entryPoint.y - points.exitPoint.y);
    }

    /**
     * Get entry point and exit point of two elements considering the direction.
     * @function getEntryAndExitPoints
     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD). Default value for dir is 'down'.
     * @param searchOrigin {DOMRect | Point} - The search origin which contains the exit point
     * @param candidateRect {DOMRect} - One of candidates which contains the entry point
     * @returns {Points} The exit point from the search origin and the entry point from a candidate
     */
    function getEntryAndExitPoints(dir = 'down', searchOrigin, candidateRect) {
      /**
       * User type definition for Point
       * @typeof {Object} Points
       * @property {Point} Points.entryPoint
       * @property {Point} Points.exitPoint
       */
      const points = {entryPoint: {x: 0, y: 0}, exitPoint:{x: 0, y: 0}};


        // Set direction
        switch (dir) {
        case 'left':
          points.exitPoint.x = searchOrigin.left;
          points.entryPoint.x = (candidateRect.right < searchOrigin.left) ? candidateRect.right : searchOrigin.left;
          break;
        case 'up':
          points.exitPoint.y = searchOrigin.top;
          points.entryPoint.y = (candidateRect.bottom < searchOrigin.top) ? candidateRect.bottom : searchOrigin.top;
          break;
        case 'right':
          points.exitPoint.x = searchOrigin.right;
          points.entryPoint.x = (candidateRect.left > searchOrigin.right) ? candidateRect.left : searchOrigin.right;
          break;
        case 'down':
          points.exitPoint.y = searchOrigin.bottom;
          points.entryPoint.y = (candidateRect.top > searchOrigin.bottom) ? candidateRect.top : searchOrigin.bottom;
          break;
        }

        // Set orthogonal direction
        switch (dir) {
        case 'left':
        case 'right':
          if (isBelow(searchOrigin, candidateRect)) {
            points.exitPoint.y = searchOrigin.top;
            points.entryPoint.y = (candidateRect.bottom < searchOrigin.top) ? candidateRect.bottom : searchOrigin.top;
          } else if (isBelow(candidateRect, searchOrigin)) {
            points.exitPoint.y = searchOrigin.bottom;
            points.entryPoint.y = (candidateRect.top > searchOrigin.bottom) ? candidateRect.top : searchOrigin.bottom;
          } else {
            points.exitPoint.y = Math.max(searchOrigin.top, candidateRect.top);
            points.entryPoint.y = points.exitPoint.y;
          }
          break;

        case 'up':
        case 'down':
          if (isRightSide(searchOrigin, candidateRect)) {
            points.exitPoint.x = searchOrigin.left;
            points.entryPoint.x = (candidateRect.right < searchOrigin.left) ? candidateRect.right : searchOrigin.left;
          } else if (isRightSide(candidateRect, searchOrigin)) {
            points.exitPoint.x = searchOrigin.right;
            points.entryPoint.x = (candidateRect.left > searchOrigin.right) ? candidateRect.left : searchOrigin.right;
          } else {
            points.exitPoint.x = Math.max(searchOrigin.left, candidateRect.left);
            points.entryPoint.x = points.exitPoint.x;
          }
          break;
        }


      return points;
    }

  /**
   * Find focusable elements within the container
   * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}
   * @function getIntersectionRect
   * @param rect1 {DOMRect} - The search origin which contains the exit point
   * @param rect2 {DOMRect} - One of candidates which contains the entry point
   * @returns {IntersectionArea} The intersection area between two elements.
   *
   * @typeof {Object} IntersectionArea
   * @property {Number} IntersectionArea.width
   * @property {Number} IntersectionArea.height
   */
  function getIntersectionRect(rect1, rect2) {
    const intersection_rect = {width: 0, height: 0, area: 0};

    const new_location = [Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)];
    const new_max_point = [Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom)];

    intersection_rect.width = Math.abs(new_location[0] - new_max_point[0]);
    intersection_rect.height = Math.abs(new_location[1] - new_max_point[1]);

    if (!(new_location[0] >= new_max_point[0] || new_location[1] >= new_max_point[1])) {
      // intersecting-cases
      intersection_rect.area = Math.sqrt(intersection_rect.width * intersection_rect.height);
    }

    return intersection_rect;
  }
  function getBoundingClientRect(element) {
    // memoization
    let rect = mapOfBoundRect && mapOfBoundRect.get(element);
    if (!rect) {
      const boundingClientRect = element.getBoundingClientRect();
      rect = {
        top: Number(boundingClientRect.top.toFixed(2)),
        right: Number(boundingClientRect.right.toFixed(2)),
        bottom: Number(boundingClientRect.bottom.toFixed(2)),
        left: Number(boundingClientRect.left.toFixed(2)),
        width: Number(boundingClientRect.width.toFixed(2)),
        height: Number(boundingClientRect.height.toFixed(2))
      };
      mapOfBoundRect && mapOfBoundRect.set(element, rect);
    }
    return rect;
  }

  /**
   * Decide whether a child element is entirely or partially Included within container visually.
   * @function isInside
   * @param containerRect {DOMRect}
   * @param childRect {DOMRect}
   * @returns {boolean}
   */
  function isInside(containerRect, childRect) {
    const rightEdgeCheck = (containerRect.left <= childRect.right && containerRect.right >= childRect.right);
    const leftEdgeCheck = (containerRect.left <= childRect.left && containerRect.right >= childRect.left);
    const topEdgeCheck = (containerRect.top <= childRect.top && containerRect.bottom >= childRect.top);
    const bottomEdgeCheck = (containerRect.top <= childRect.bottom && containerRect.bottom >= childRect.bottom);
    return (rightEdgeCheck || leftEdgeCheck) && (topEdgeCheck || bottomEdgeCheck);
  }

  /**
   * Decide whether this element is entirely or partially visible within the viewport.
   * Note: rect1 is outside of rect2 for the dir
   * @function isOutside
   * @param rect1 {DOMRect}
   * @param rect2 {DOMRect}
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @returns {boolean}
   */
  function isOutside(rect1, rect2, dir) {
    switch (dir) {
    case 'left':
      return isRightSide(rect2, rect1);
    case 'right':
      return isRightSide(rect1, rect2);
    case 'up':
      return isBelow(rect2, rect1);
    case 'down':
      return isBelow(rect1, rect2);
    default:
      return false;
    }
  }

  /* rect1 is right of rect2 */
  function isRightSide(rect1, rect2) {
    return rect1.left >= rect2.right || (rect1.left >= rect2.left && rect1.right > rect2.right && rect1.bottom > rect2.top && rect1.top < rect2.bottom);
    //rect1.bottom > rect2.top && rect1.top < rect2.bottom; at least 2 rec should be overlapped
  }

  /* rect1 is below of rect2 */
  function isBelow(rect1, rect2) {
    console.log("isBelow");
    return rect1.top >= rect2.bottom || (rect1.top >= rect2.top && rect1.bottom > rect2.bottom && rect1.left < rect2.right && rect1.right > rect2.left);
  }

  /* rect1 is completely aligned or partially aligned for the direction */
  function isAligned(rect1, rect2, dir) {
    switch (dir) {
    case 'left' :
      /* falls through */
    case 'right' :
      return rect1.bottom > rect2.top && rect1.top < rect2.bottom;
    case 'up' :
      /* falls through */
    case 'down' :
      return rect1.right > rect2.left && rect1.left < rect2.right;
    default:
      return false;
    }
  }
  </script>
</html>
